### 클래스의 상속

```cpp
#include <iostream>

class Food
{
	public:
		int price;
};

class Fruit : public Food
{
	public:
		int code;
};
```

- 어떤 클래스를 상속받아 파생 클래스를 만들기 위해서는 클래스명 뒤에 `public : 기본 클래스명`을 기술한다.
- 파생 클래스의 멤버는 '자신의 멤버 + 기본 클래스의 멤버'이다.
- 기본 클래스의 멤버가 `public`, `protected`일 때는 파생 클래스에서 접근할 수 있고, `private`일 때는 접근할 수 없다.

```cpp
class Apple : public Fruit, public Food
{
};
```

- 복수의 기본 클래스로부터 하나의 파생 클래스를 만들 수 있으며, 이것을 **다중 상속**이라고 한다.

### 멤버 함수의 재정의

기본 클래스에서 정의한 멤버 함수를 파생 클래스에서 `재정의`할 수 있다. **함수명, 인수, 반환값은 동일해야** 하며, 파생 클래스에서 재정의 한 쪽의 함수가 호출된다.

### 가상함수

그러나 기본 클래스에서 해당 멤버 함수를 호출하면, 재정의 전의 멤버 함수가 호출된다. 이럴 때는 기본 클래스의 멤버 함수를 `가상 함수`로 설정하면 된다.

`virtual void SetPrice(int myPrice) {};` 처럼 함수 앞에 `virtual`을 붙인다.

### 순수 가상 함수

기본 클래스에서 내용을 정의하지 않는 가상 함수를 순수 가상 함수라고 한다. 순수 가상 함수를 사용하면 해당 클래스를 사용한 오브젝트를 만들 수 없다. 따라서 해당 클래스는 그냥 기본적인 틀과 같은 역할을 하게 된다.

### 소멸자를 가상 함수로

상속할 가능성이 있는 클래스의 소멸자는 가상 함수로 만들어두는 것이 좋다. 만약 기본 클래스가 파생 클래스의 포인터를 가지고 있을 때, 가상 함수화 하지 않은 소멸자는 오브젝트가 삭제될 때 실행되지 않기 때문이다.

`virtual void SetPrice(int myPrice) {} = 0;` 끝에 `=0`이라고 써야 한다.